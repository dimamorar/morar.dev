---
title: "JavaScript"
description: "Scope determines where variables and functions are accessible in the code."
---

## Scope & Hoisting

> Scope determines where variables and functions are accessible in the code.
> 
> 
> **Hoisting** is a mechanism where declarations are registered in memory before program execution.
> 

---

### ðŸ§© Scope

- **Function Scope** â€” variables declared with `var` are visible only inside the function.
- **Block Scope** â€” variables declared with `let` and `const` are accessible only within the `{ ... }` block.

When creating a scope, the engine forms a **Lexical Environment** â€” an internal structure where links to identifiers and their values are stored.

Each environment is linked to an external one, forming a **Scope Chain**.

---

### âš™ï¸ Hoisting

- During the **compilation phase**, variable and function declarations are registered in memory before code execution.
- For `var`, the declaration is hoisted and initialized as `undefined`.
- For `let` and `const`, declarations are hoisted but remain in the **Temporal Dead Zone (TDZ)** until initialization.
- **Function declarations** are hoisted completely (both name and function body), so they can be called before declaration.

---

### ðŸ’¡ Key Idea

- Scope defines **boundaries of variable accessibility**.
- Hoisting explains **why access is possible before declaration**.
- Lexical Environment forms the basis for the **scope chain and closures**.
- `TDZ` prevents the use of `let` and `const` before their initialization.

---

> The Lexical Environment lies at the core of the Closures mechanism â€” functions in JavaScript remember their environment and can access variables from the outer scope even after it has completed.

## Data Types in JavaScript

> In JavaScript, there are two main data types: primitive and reference.
> Primitives store the value itself, while reference types store a **reference to the memory area** where that value is located.

---

### ðŸ§© Primitive Types (Primitive Types)

Store the **actual value**, not a reference.
Passed **by value**.

| Type | Description |
| ------------- | ----------------------------------------------------------- |
| **Number** | Numeric values: `10`, `3.14`, `-5` |
| **String** | Text strings: `"Hello"`, `'JS'` |
| **Boolean** | Logical values: `true`, `false` |
| **Null** | Intentional absence of a value |
| **Undefined** | Variable declared but without a value |
| **Symbol** | Unique and immutable identifier |
| **BigInt** | Very large integers, larger than `Number.MAX_SAFE_INTEGER` |

```jsx
typeof 42;        // 'number'
typeof 'Hello';   // 'string'
typeof null;      // 'object' (historical bug)
typeof Symbol();  // 'symbol'

```

ðŸ“˜ Primitives are **immutable** â€” their values cannot be changed without creating a new one.

---

### ðŸ§© Reference Types (Reference Types)

Store a **reference (address)** to an object in memory.
Passed **by reference**.

| Type | Description |
| --- | --- |
| **Object** | Collection of keyâ€“value pairs |
| **Array** | Ordered list of values (a special type of object) |
| **Function** | Object that can be called (has an internal `[[Call]]` method) |

```jsx
typeof {};             // 'object'
typeof [];             // 'object'
typeof function() {};  // 'function'
```

ðŸ“˜ Arrays and functions are **subtypes of objects**, so `typeof []` returns `'object'`.

---

### ðŸ’¡ Key Ideas

- **Primitives** store values directly â†’ immutable, compared by value.
- **Reference types** store references â†’ mutable, compared by memory address.
- `typeof null === 'object'` â€” a **historical bug** in the language.
- Functions have their own `function` type, although they are a subtype of object.
- For accurate type determination of complex structures, use:

```jsx
Array.isArray([]);         // true
obj.constructor === Object // true

```
