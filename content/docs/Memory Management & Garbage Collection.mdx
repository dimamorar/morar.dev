---
title: "Memory Management & Garbage Collection"
description: "Memory management in JavaScript happens automatically: the engine allocates memory for created values and frees it when they are no longer reachable."
---

## Memory Management & Garbage Collection

> Memory management in JavaScript happens automatically: the engine allocates memory for created values and frees it when they are no longer reachable.
> This process is controlled by the **Garbage Collector**.

---

### ğŸ§© Memory Allocation

- Memory is allocated upon creation of:
    - **Primitives** (on the stack);
    - **Objects, arrays, functions** (on the heap);
    - **Closures** â€” references to outer variables are kept as long as the function exists.
- When a value becomes **unreachable** (no active references to it), it is marked for deletion.

```jsx
let user = { name: 'Alice' };
user = null; // object is now unreachable, memory will be cleared

```

---

### ğŸ§  Garbage Collection Mechanism

- GC is based on the principle of **reachability**.
- **Mark-and-sweep** algorithm:
    1. The engine marks all values reachable from root objects (`window`, `globalThis`, call stack).
    2. Everything not marked as reachable is removed from memory.

ğŸ“˜ Modern engines use optimized algorithms: **generational**, **incremental**, **concurrent**, and **ephemeral GC** â€” so that collection doesn't block the main thread.

---

### âš™ï¸ Typical Causes of Memory Leaks

1. **Uncleared references to DOM elements**
    - A removed element stays in memory if JS code still references it.
2. **Global variables and forgotten timers**
    - `setInterval` or `setTimeout` continue to hold references.
3. **Closures**
    - Captured variables stay in memory if the function isn't destroyed.
4. **Unbounded cache**
    - Storing growing structures (`Map`, arrays) without size control.

---

### ğŸ§© WeakMap and WeakSet

- Store **weak references** â€” keys do not prevent garbage collection.
- When an object becomes unreachable, its entries are automatically removed from the collection.

```jsx
let cache = new WeakMap();
let obj = {};
cache.set(obj, "data");
obj = null; // entry will be removed by GC

```

ğŸ“˜ Used for **caches, private data, and metadata** where manual cleanup management isn't needed.

---

### ğŸ’¡ Key Ideas

- GC frees memory automatically based on **object reachability**.
- The main goal is to **avoid leaks** by not holding onto unnecessary references.
- **WeakMap/WeakSet** help securely store data without interfering with garbage collection.
- Avoid global variables and "eternal" closures to control memory consumption.
