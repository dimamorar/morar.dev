---
title: "NextJS"
description: "App Router is a modern RSC-oriented architecture in Next.js that organizes the interface through segments, layouts, and streaming rendering."
---

## **App Router in Next.js and its differences from Pages Router**

> App Router is a modern RSC-oriented architecture in Next.js that organizes the interface through segments, layouts, and streaming rendering.  
> It minimizes client-side JavaScript and moves most of the logic to the server.  
> Pages Router is the previous model that relied on client-side React and separate lifecycle functions for SSR/SSG.

---

### Technical Explanation

#### App Router (`/app` directory)

- Built on **React Server Components**, where the server is the source of UI.
    
- Has a hierarchical system of files: **layout.js**, **page.js**, **loading.js**, **error.js**, **not-found.js**, **route.js**.
    
- Supports **streaming**, **partial rendering**, **parallel routes**, **intercepting routes**, and **Server Actions**.
    
- Unified data fetching model via **fetch() with caching and revalidation**.
    
- Smaller volume of client JS, less hydration.
    

#### Pages Router (`/pages` directory)

- Works through **Client Components** + SSR/SSG in the form of `getStaticProps`, `getServerSideProps`, `getInitialProps`.
    
- Uses global files `_app.js`, `_document.js` for composition.
    
- Does not support RSC, streaming, layout segments, or Server Actions.
    
- Hydration is more complex, bundle is larger.
    

#### Main Architectural Differences

- App Router is **server-first**, Pages Router is **client-first**.
    
- App Router forms the UI through a **layout tree**, Pages Router — through a global container.
    
- App Router automates caching and rendering, Pages Router — no.
    
- App Router significantly reduces runtime on the client.


## **How rendering modes work in Next.js (RSC, SSR, SSG, ISR) and when to use them**

> Next.js combines several rendering models, where the base is React Server Components, and SSR/SSG/ISR are managed through cache and update policies.  
> App Router uses the server as the main source of UI and decides when to return a cached or dynamic response.  
> The choice of mode depends on data stability, response speed, and personalization requirements.

---

### Technical Explanation

#### React Server Components (RSC)

- The default mode of App Router — UI is built **on the server without JS hydration**.
    
- Ideal for stable content, heavy logic, and working with databases.
    
- Can be streamed in parts via **React Suspense**.
    

#### SSR (Server-Side Rendering)

- Rendering is **performed on every request**, without using the cache.
    
- Used when:
    
    - personalization is needed;
        
    - data changes on every request;
        
    - secure server-only operations are needed.
        
- In App Router, SSR is activated:
    
    - via **dynamic parameters**,
        
    - `fetch({ cache: "no-store" })`,
        
    - `export const dynamic = "force-dynamic"`.
        

#### SSG (Static Site Generation)

- The page is generated **once during build** and cached as static HTML + RSC payload.
    
- Suitable for stable pages: marketing, documentation, blogs.
    

#### ISR (Incremental Static Regeneration)

- Next.js updates static pages **in the background after the `revalidate` time expires**.
    
- The user receives the old version while the new one is being generated.
    
- In App Router, it is implemented via `export const revalidate = N`.
    

#### When to Choose What
- **RSC** — default option, universal.
- **SSR** — personal data, admin panels, dashboards.
- **SSG** — marketing, blog, FAQ.
- **ISR** — semi-dynamic pages: news, product catalogs.



## **React Server Components and why they are at the core of App Router**

> React Server Components execute on the server and allow building UI without passing unnecessary JavaScript to the browser.  
> They enable rendering data, executing server logic, and forming the component tree before sending it to the client.  
> In App Router, RSC is the default mode that defines the architecture of rendering, caching, and navigation.

---

### Technical Explanation

#### The Main Idea of RSC

- Components execute **in the server environment**, not the browser.
    
- The result of their work is a **serialized tree** that React can combine with client components.
    
- No access to DOM, state, effect hooks, and browser APIs.
    

#### Why they are the core of App Router

- Allow moving heavy logic (requests, data processing, list rendering) to the server.
    
- Provide a **minimal client bundle** and reduce hydration.
    
- Building UI via RSC makes rendering **streaming** and **partial** (partial rendering) via Suspense.
    
- Enables server interactions without API endpoints (e.g., **Server Actions**).
    

#### What tasks RSC solve

- Working with databases and secrets without exposure to the client.
    
- Flexible caching at the fetch level and at the route level.
    
- Creating fast UIs where the client receives ready HTML + RSC payload.
    

#### When Client Components are needed

- Interactivity (events, state, useEffect).
    
- Working with DOM API.
    
- Animations, drag-n-drop, client-only logic.



## **When a component becomes a Client Component and how it affects the bundle**

> A component becomes a Client Component when it contains client logic — state, events, useEffect, or DOM work.  
> In such components, Next.js adds a special marker `"use client"`, which forces them to be passed to the client bundle.  
> This increases the amount of JavaScript in the browser and reduces performance compared to server components.

---

### Technical Explanation

#### What makes a component a Client Component

A component becomes a client one if it:

- contains the **"use client"** directive in the first line of the file;
    
- uses **React Hooks**: `useState`, `useEffect`, `useReducer`, `useRef`;
    
- has browser APIs: `window`, `document`, `localStorage`;
    
- handles events (`onClick`, `onChange`, `onSubmit`, etc.).
    

#### How Next.js defines a Client Component

- Any file with `"use client"` either at the top or in nested imports.
    
- If a Client Component imports a Server Component — it's an error.
    
- If a Server Component imports a Client Component — it's allowed.
    

#### How it affects the bundle

- The code of such a component goes into the **client-side bundle**.
    
- It needs to be **hydrated**, which increases time to interactivity.
    
- More client components → more JS on the browser side.
    
- Client Components **are not cached** like RSC because they execute in the browser.
    

#### Example of a minimal client component

```jsx
"use client";

export default function Counter() {
  const [value, setValue] = useState(0);
  return <button onClick={() => setValue(value + 1)}>{value}</button>;
}
```
