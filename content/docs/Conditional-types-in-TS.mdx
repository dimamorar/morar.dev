---
title: "Conditional types in TS"
description: "Conditional types allow creating types that depend on conditions, similar to the ternary operator in JavaScript (A extends B ? X : Y)."
---

> Conditional types allow creating types that depend on conditions, similar to the ternary operator in JavaScript (A extends B ? X : Y).
> This enables building flexible and adaptive type expressions based on the relationship between types.

---

### ðŸ§© Syntax

```tsx
T extends U ? X : Y
```

- If `T` **extends** type `U`, the result will be type `X`.
- Otherwise â€” type `Y`.

```tsx
type IsString<T> = T extends string ? "yes" : "no";

type A = IsString<string>; // "yes"
type B = IsString<number>; // "no"
```

---

### ðŸ§© Use in Utility Types

Conditional types are the foundation of many built-in TypeScript utility types (`Exclude`, `Extract`, `NonNullable`):

```tsx
type Exclude<T, U> = T extends U ? never : T;

type Result = Exclude<"a" | "b" | "c", "a" | "c">;
// "b"
```

- Here, each element `"a" | "b" | "c"` is checked separately â€” this is called a **distributive conditional type**.

---

### ðŸ§© Nested Conditional Types

- Types can be nested for complex logic checks:

```tsx
type Check<T> = T extends string
  ? "string"
  : T extends number
  ? "number"
  : "other";

type A = Check<42>;       // "number"
type B = Check<"test">;   // "string"
type C = Check<boolean>;  // "other"
```

---

### ðŸ’¡ Key Ideas

- Conditional types = **"ifâ€“else" type logic** for checking relationships between types.
- Heavily used in generic utilities and type libraries.
- Enable creating **adaptive types** that change based on input.
