---
title: "How Event Loop Works"
description: "The Event Loop is a mechanism that controls the order of code execution in JavaScript."
---

## How Event Loop Works

> The Event Loop is a mechanism that controls the order of code execution in JavaScript.
> It allows single-threaded JS to process asynchronous tasks, ensuring **continuous program execution without blocking**.

---

### ðŸ§© Core Idea

- JavaScript works in **one thread**, where the call stack (**Call Stack**) is executed.
- Asynchronous operations (timers, I/O, promises) are handled by **external APIs** of the environment (browser, Node.js).
- Upon completion, the operation adds a callback to the corresponding **task queue**.
- The **Event Loop** monitors the stack: when it is empty, it takes a task from the queue and places it in the stack for execution.

---

### âš™ï¸ Execution Order and Priority

1. All **synchronous code** (code in the call stack) is executed.
2. When the stack is empty, the **Event Loop** takes **one macrotask** from the queue and executes it.
3. After that, **all microtasks** are executed (the queue is cleared completely).
4. Then the browser can perform **frame rendering**.
5. The cycle repeats.

> If new microtasks are created during the execution of microtasks â€” they are also executed in the same pass until the queue is empty.

---

### ðŸ§  Microtasks

- `Promise.then`, `.catch`, `.finally`
- `queueMicrotask()`
- `MutationObserver`
- _(Node.js)_ `process.nextTick()` â€” executed **earlier than regular microtasks**

---

### â± Macrotasks

- `setTimeout`, `setInterval`
- `setImmediate` _(Node.js)_
- `postMessage`, `MessageChannel`
- DOM event callbacks
- `requestAnimationFrame` â€” called **between microtask clearing and frame rendering**, formally does not belong to any category.

---

### âš–ï¸ Microtask vs Macrotask

| Characteristic | **Microtask** | **Macrotask** |
| ---------------- | ----------------------------------------------------------- | ----------------------------------------------- |
| **Examples** | `Promise.then`, `queueMicrotask`, `MutationObserver` | `setTimeout`, `setInterval`, DOM events |
| **Source** | Internal JS APIs | External environment APIs (browser / Node.js) |
| **Priority** | Executed **immediately after the current task**, before rendering | Executed **one per iteration** of the Event Loop |
| **Usage** | Short operations requiring immediate processing | Asynchronous operations, timers, events |
| **Sequence** | All microtasks are executed **before the next macrotask** | After clearing microtasks and possible rendering |

> In other words, microtasks are executed earlier than macrotasks â€” they create an internal priority cycle within one step of the Event Loop.

---

### ðŸ’¡ Key Ideas

- The Event Loop coordinates the execution of **synchronous and asynchronous code**.
- **Microtasks** are always executed **before the next macrotask**.
- Promises and timers fall into different queues and are processed at different stages of the cycle.
- This mechanism guarantees **smooth, non-blocking operation of JS applications**.

---

### ðŸ”— Links

- [Asynchronous JavaScript: The Event Loop, Callbacks, Promises, and Async/Await â€” Medium](https://www.notion.so/Asynchronous-JavaScript-The-Event-Loop-Callbacks-Promises-and-Async-Await-by-Viduni-Wickramara-bc1733f64e3f4aaa974912c88774260e?pvs=21)
- https://www.deepintodev.com/blog/how-javascript-works-behind-the-scenes
